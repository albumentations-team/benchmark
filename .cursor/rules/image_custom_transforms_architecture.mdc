---
description: Architecture of the image benchmark system — how transform spec files work, what BenchmarkRunner expects, and how built-in vs custom transforms differ.
globs: benchmark/**/*.py, benchmark/transforms/**/*.py, benchmark/cli.py, examples/*.py
alwaysApply: false
---

# Image Benchmark Architecture

## Transform Spec File Contract

Every spec file (built-in or custom) must define three things at module level:

```python
LIBRARY = "albumentationsx"  # controls which venv/requirements are used

def __call__(transform: Any, image: Any) -> Any:  # noqa: N807
    """Called once per image during benchmarking."""
    return transform(image=image)["image"]

TRANSFORMS = [
    {"name": "HorizontalFlip", "transform": A.HorizontalFlip(p=1)},
]
```

Key details:
- `__call__` receives **a single image**, not a batch — the runner loops over images itself
- `name` appears verbatim in result JSON keys and comparison tables
- All transforms must have `p=1` for deterministic benchmarking
- The module is validated by `load_from_python_file()` in `benchmark/runner.py`

## BenchmarkRunner (`benchmark/runner.py`)

`BenchmarkRunner` is unified for both image and video — parameterized by `MediaType`:

```python
BenchmarkRunner(
    library=library,        # str, used for image loader selection
    data_dir=data_dir,      # Path to images (RGB only, grayscale skipped)
    transforms=transforms,  # list[{"name": str, "transform": Any}]
    call_fn=call_fn,        # the __call__ function from spec file
    media_type=MediaType.IMAGE,
    num_items=1000,
    max_warmup_iterations=1000,
    warmup_subset_size=10,
    slow_threshold=0.1,
    min_iterations_before_stopping=10,
    max_time_per_transform=60,
)
```

Warmup early-stops if:
- `time_per_image > 0.1` sec (after 10+ iterations)
- total warmup time > 60 sec

## Built-in vs Custom Transform Files

**Built-in** (`benchmark/transforms/*_impl.py`):
- Import `TRANSFORM_SPECS` from `benchmark/transforms/specs.py`
- Use a `create_transform(spec)` factory to build transforms from the shared spec
- Ensure all libraries benchmark the same operations for fair comparison

**Custom** (user files, e.g. `examples/custom_image_transforms.py`):
- Define `TRANSFORMS` directly with arbitrary transform instances
- Full control over parameters; useful for parametric testing

```bash
# Built-in (all libraries)
python -m benchmark.cli run --media image -d /images -o output/

# Single library
python -m benchmark.cli run --media image -d /images -o output/ --libraries albumentationsx

# Custom spec
python -m benchmark.cli run --media image -d /images -o output/ --spec my_transforms.py

# Single transform regression check
python -m benchmark.cli run --media image -d /images -o output/ \
  --libraries albumentationsx --transforms HorizontalFlip
```

## Image Loading

Images are loaded via `get_image_loader(library)` from `benchmark/utils.py`. The runner:
1. Pre-checks each file with `cv2.IMREAD_UNCHANGED` — skips grayscale (< 3 channels)
2. Loads with the library-specific loader (numpy array, PIL Image, torch Tensor, etc.)
3. Only processes RGB images

## Output Format

```json
{
  "metadata": {
    "system_info": {...},
    "library_versions": {...},
    "thread_settings": {"OMP_NUM_THREADS": "1", ...},
    "benchmark_params": {"num_images": 2000, "num_runs": 5, ...}
  },
  "results": {
    "HorizontalFlip": {
      "supported": true,
      "median_throughput": 1234.5,
      "std_throughput": 45.2,
      "warmup_iterations": 12,
      "variance_stable": true,
      "early_stopped": false,
      "early_stop_reason": null
    }
  }
}
```

## Library-specific `__call__` patterns

**AlbumentationsX** — single image, dict access:
```python
def __call__(transform, image):
    return np.ascontiguousarray(transform(image=image)["image"])
```

**torchvision** — expects `(C, H, W)` tensor:
```python
def __call__(transform, image):
    return transform(image)
```

**imgaug** — uses `augment_image`:
```python
def __call__(transform, image):
    return transform.augment_image(image)
```

**augly** — PIL Image, modifies in-place so copy first:
```python
def __call__(transform, image):
    return transform(image.copy())
```

**kornia** — GPU tensor `(C, H, W)`, unsqueeze for batch dim:
```python
def __call__(transform, image):
    return transform(image.unsqueeze(0)).squeeze(0)
```

## Differences from Video Benchmark

| Aspect | Image | Video |
|--------|-------|-------|
| `__call__` receives | single image | single video `(T, H, W, C)` |
| Slow threshold | 0.1 sec/image | 2.0 sec/video |
| Default num items | 2000 images | 50 videos |
| Warmup subset | 10 images | 3 videos |
| Extra libraries | imgaug, augly | — |
